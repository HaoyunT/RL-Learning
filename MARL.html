<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>多智能体强化学习（MARL）| Yun</title>
<!-- 数学公式渲染 -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']]
    }
  };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Prism.js 样式与脚本 -->
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-coy.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

<style>
body {
  margin: 0;
  font-family: "Segoe UI", "Roboto", -apple-system, sans-serif;
  background: linear-gradient(135deg, #1a233c 0%, #2d3b60 40%, #1a2332 100%);
  color: #f5f5f5;
  line-height: 1.8;
  scroll-behavior: smooth;
}

header {
  position: sticky;
  top: 0;
  z-index: 100;
  text-align: center;
  background: rgba(26, 35, 60, 0.92);
  padding: 28px 20px 18px;
  backdrop-filter: blur(10px);
  border-bottom: 1px solid rgba(59, 130, 246, 0.35);
  box-shadow: 0 6px 22px rgba(0, 0, 0, 0.5);
}

header h1 {
  font-size: 2.3rem;
  color: #3b82f6;
  margin: 0;
  font-weight: 700;
  letter-spacing: 1.5px;
}

nav ul {
  list-style: none;
  display: flex;
  justify-content: center;
  flex-wrap: wrap;
  gap: 10px;
  padding: 0;
  margin: 18px 0 0;
}

nav a {
  color: #dbeafe;
  text-decoration: none;
  font-weight: 600;
  font-size: 0.95rem;
  padding: 6px 16px;
  border-radius: 6px;
  transition: all 0.3s ease;
  background: rgba(59, 130, 246, 0.1);
  border: 1px solid rgba(59, 130, 246, 0.2);
}

nav a:hover, nav a.active {
  color: #3b82f6;
  background: rgba(59, 130, 246, 0.2);
  border-color: rgba(59, 130, 246, 0.5);
  box-shadow: 0 0 14px rgba(59, 130, 246, 0.35);
}

.container {
  display: flex;
  position: relative;
  z-index: 5;
  max-width: 1400px;
  margin: 30px auto;
  gap: 30px;
  padding: 0 20px 40px;
}

aside {
  position: sticky;
  top: 130px;
  width: 260px;
  height: fit-content;
  background: rgba(26, 35, 60, 0.88);
  border: 1px solid rgba(59, 130, 246, 0.25);
  border-radius: 12px;
  padding: 22px;
  backdrop-filter: blur(12px);
  flex-shrink: 0;
}

aside h3 {
  color: #3b82f6;
  font-size: 1.15rem;
  margin: 0 0 16px 0;
  padding-bottom: 10px;
  border-bottom: 2px solid rgba(59, 130, 246, 0.35);
}

aside ul {
  list-style: none;
  margin: 0;
  padding: 0;
  display: grid;
  gap: 6px;
}

aside a {
  color: #dbeafe;
  text-decoration: none;
  font-size: 0.9rem;
  padding: 8px 12px;
  border-radius: 6px;
  transition: all 0.2s ease;
  border-left: 3px solid transparent;
  background: transparent;
}

aside a:hover, aside a.active {
  color: #3b82f6;
  background: rgba(59, 130, 246, 0.12);
  border-left-color: #3b82f6;
  padding-left: 16px;
}

main {
  flex: 1;
  min-width: 0;
}

.chapter {
  background: rgba(26, 35, 60, 0.82);
  border: 1px solid rgba(59, 130, 246, 0.2);
  border-radius: 14px;
  padding: 36px;
  margin-bottom: 35px;
  transition: all 0.3s ease;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.45);
}

.chapter:hover {
  border-color: rgba(59, 130, 246, 0.4);
  transform: translateY(-3px);
  box-shadow: 0 16px 38px rgba(0, 0, 0, 0.55);
}

.chapter h2 {
  color: #3b82f6;
  font-size: 1.85rem;
  margin: 0 0 24px 0;
  padding-bottom: 12px;
  border-bottom: 2px solid rgba(59, 130, 246, 0.3);
  font-weight: 700;
}

.chapter h3 {
  color: #60a5fa;
  font-size: 1.25rem;
  margin-top: 26px;
  border-left: 4px solid rgba(96, 165, 250, 0.6);
  padding-left: 12px;
}

.chapter p, .chapter li {
  color: #e8f0ed;
}

.chapter strong {
  color: #60a5fa;
}

.chapter code {
  background: rgba(59, 130, 246, 0.15);
  color: #dbeafe;
  padding: 3px 6px;
  border-radius: 4px;
}

/* 代码块样式 */
pre[class*="language-"] {
  background: linear-gradient(135deg, #1a233c 0%, #2d3b60 100%) !important;
  padding: 20px !important;
  padding-left: 3.2em !important;
  border-radius: 10px !important;
  overflow-x: auto !important;
  font-size: 0.92rem !important;
  line-height: 1.6 !important;
  border: 1px solid rgba(59, 130, 246, 0.3) !important;
  position: relative;
  font-family: 'Fira Code', 'Courier New', 'Consolas', 'Monaco', monospace !important;
  box-shadow: 0 4px 20px rgba(59, 130, 246, 0.2) !important;
}

pre.line-numbers {
  padding-left: 60px !important;
}

.line-numbers .line-numbers-rows {
  left: 0 !important;
  width: 3em !important;
  background: transparent !important;
  border-right: 1px solid #444 !important;
}

.line-numbers-rows > span:before {
  color: rgba(59, 130, 246, 0.8) !important;
  font-weight: bold;
}

pre code {
  color: inherit !important;
  background: none !important;
  font-family: inherit !important;
  font-size: inherit !important;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #9c9c9c !important;
  font-style: italic;
}

.token.punctuation {
  color: #f8f8f2 !important;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #ff79c6 !important;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: #50fa7b !important;
}

.token.operator,
.token.entity,
.token.url {
  color: #8be9fd !important;
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #bd93f9 !important;
}

.token.function,
.token.class-name {
  color: #ffb86c !important;
}

.token.regex,
.token.important,
.token.variable {
  color: #f1fa8c !important;
}

pre[class*="language-"] code,
pre[class*="language-"] {
  color: #f8f8f2 !important;
}

pre[class*="language-"]:hover {
  box-shadow: 
    0 12px 48px rgba(59, 130, 246, 0.3),
    inset 0 1px 0 rgba(255,255,255,0.1) !important;
  transform: translateY(-2px);
  transition: all 0.3s ease;
}

pre[class*="language-"]::-webkit-scrollbar {
  height: 10px;
  background: rgba(59, 130, 246, 0.1);
}

pre[class*="language-"]::-webkit-scrollbar-thumb {
  background: rgba(59, 130, 246, 0.5);
  border-radius: 5px;
  transition: background 0.3s;
}

pre[class*="language-"]::-webkit-scrollbar-thumb:hover {
  background: rgba(59, 130, 246, 0.8);
}

table {
  width: 100%;
  border-collapse: collapse;
  margin: 18px 0;
  background: rgba(59, 130, 246, 0.06);
  border-radius: 10px;
  overflow: hidden;
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.35);
}

table th, table td {
  padding: 12px 16px;
  border-bottom: 1px solid rgba(59, 130, 246, 0.2);
  color: #e0f2f1;
}

table th {
  background: rgba(59, 130, 246, 0.22);
  color: #f0fdfa;
  font-size: 1.05rem;
}

table tr:last-child td {
  border-bottom: none;
}

footer {
  text-align: center;
  padding: 28px 20px;
  background: rgba(26, 35, 60, 0.9);
  border-top: 1px solid rgba(59, 130, 246, 0.3);
  color: #dbeafe;
  margin-top: 60px;
  font-size: 0.9rem;
}

footer span {
  color: #3b82f6;
  font-weight: 600;
}

@media (max-width: 1024px) {
  .container {
    flex-direction: column;
  }
  aside {
    position: relative;
    top: auto;
    width: 100%;
  }
}

@media (max-width: 768px) {
  header h1 {
    font-size: 2rem;
  }
  nav a {
    font-size: 0.85rem;
    padding: 4px 12px;
  }
  .container {
    padding: 0 12px 30px;
  }
  .chapter {
    padding: 24px;
  }
}
</style>
</head>
<body>

<header>
  <h1>多智能体强化学习（MARL）</h1>
  <nav>
    <ul>
      <li><a href="index.html">首页</a></li>
      <li><a href="home.html">基础理论</a></li>
      <li><a href="advanced.html">进阶算法</a></li>
      <li><a href="MARL.html" class="active">多智能体学习</a></li>
      <li><a href="papers.html">论文研读</a></li>
    </ul>
  </nav>
</header>

<div class="container">
  <aside>
    <h3>章节目录</h3>
    <ul>
      <li><strong>环境部署指南</strong>
        <ul>
          <li><a href="#env_setup">服务器环境配置</a></li>
        </ul>
      </li>
      <li><strong>Part 0：UAV-MARL 概述</strong>
        <ul>
          <li><a href="#part0">概览与挑战</a></li>
        </ul>
      </li>
      <li><strong>Part 1：基础方法</strong>
        <ul>
          <li><a href="#iql">IQL（基线）</a></li>
          <li><a href="#vdn_qmix">VDN / QMIX（价值分解）</a></li>
          <li><a href="#maddpg_matd3_masac">MADDPG / MATD3 / MASAC（连续动作）</a></li>
        </ul>
      </li>
      <li><strong>Part 2：高级协作方法</strong>
        <ul>
          <li><a href="#coma">COMA（信用分配）</a></li>
          <li><a href="#mappo">MAPPO（规模与稳定性）</a></li>
          <li><a href="#comm">显式通信（CommNet / TarMAC / DIAL）</a></li>
        </ul>
      </li>
      <li><strong>Part 3：Graph-MARL</strong>
        <ul>
          <li><a href="#graph_marl">Graph-MARL（GNN / GAT / DGN / G2ANet）</a></li>
        </ul>
      </li>
      <li><strong>Part 4：对抗博弈</strong>
        <ul>
          <li><a href="#part4">对抗 MARL（博弈方法）</a></li>
        </ul>
      </li>
      <li><strong>Part 5：案例与模拟器</strong>
        <ul>
          <li><a href="#papers">经典论文</a></li>
          <li><a href="#sims">模拟器与工程</a></li>
        </ul>
      </li>
      <li><a href="#summary">总结与展望</a></li>
    </ul>
  </aside>

  <main>
    <!-- Environment Setup Guide -->
    <section id="env_setup" class="chapter">
      <h2>实验室服务器环境部署（PyMARL2 + CUDA + PyTorch）</h2>
      <p>本文记录我在实验室服务器上从零开始部署多智能体强化学习（MARL）环境的完整过程，包含：创建数据盘目录、安装 Miniconda、创建 Conda 环境、部署 PyMARL2、安装 GPU 版 PyTorch（CUDA 12.1）以及验证 GPU 是否可用。</p>
      <p><strong>适用环境：</strong>CUDA 12.x + RTX30 系列 GPU + Ubuntu + Conda</p>

      <h3>1. 在数据盘 /disk 上创建工作目录</h3>
      <p>服务器的数据盘是 <code>/dev/sda1</code>，挂载到 <code>/disk</code>。</p>
      <p>需要管理员帮助创建我的专属目录：</p>
      <pre><code class="language-bash">sudo mkdir -p /disk/haoyun
sudo chown -R haoyun:haoyun /disk/haoyun</code></pre>
      <p>然后在其中建立三大常用目录：</p>
      <pre><code class="language-bash">mkdir -p /disk/haoyun/projects
mkdir -p /disk/haoyun/checkpoints
mkdir -p /disk/haoyun/datasets</code></pre>
      <p>全部后续代码、模型、输出都放这里，避免占满系统盘。</p>

      <h3>2. 安装 Miniconda</h3>
      <p>如果服务器没有 conda，则手动安装：</p>
      <pre><code class="language-bash">cd ~
wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh
bash Miniconda3-latest-Linux-x86_64.sh
source ~/.bashrc</code></pre>
      <p>检查是否成功：</p>
      <pre><code class="language-bash">conda --version</code></pre>

      <h3>3. 创建 PyMARL2 的 Conda 环境（Python 3.9）</h3>
      <pre><code class="language-bash">conda create -n pymarl2 python=3.9 -y
conda activate pymarl2</code></pre>

      <h3>4. 克隆 PyMARL2 到数据盘</h3>
      <pre><code class="language-bash">cd /disk/haoyun/projects
git clone https://github.com/hijkzzz/pymarl2
cd pymarl2</code></pre>

      <h3>5. 安装 PyMARL2 依赖</h3>
      <p>PyMARL2 没有 <code>requirements.txt</code>，需要运行官方脚本（会比较慢）：</p>
      <pre><code class="language-bash">bash install_dependencies.sh</code></pre>

      <h3>6. 安装 GPU 版 PyTorch（适配 CUDA 12.2 → 使用 cu121）</h3>
      <p>执行：</p>
      <pre><code class="language-bash">pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121</code></pre>
      <p>验证 GPU 是否可用：</p>
      <pre><code class="language-python">python - << 'EOF'
import torch
print(torch.cuda.is_available())
print(torch.cuda.get_device_name(0))
EOF</code></pre>
      <p>输出示例：</p>
      <pre><code class="language-text">True
NVIDIA GeForce RTX 3090</code></pre>
      <p>说明 PyTorch GPU 安装成功。</p>

      <h3>7. 安装 SMAC 环境</h3>
      <pre><code class="language-bash">pip install git+https://github.com/oxwhirl/smac.git</code></pre>
      <p>（这是 PyMARL2 必需依赖）</p>

      <h3>8. 运行测试任务验证 PyMARL2 是否工作</h3>
      <p>选择空闲 GPU，如 GPU 6：</p>
      <pre><code class="language-bash">export CUDA_VISIBLE_DEVICES=6
python src/main.py --config=qmix --env=smac --map=MMM2</code></pre>
      <p>如果训练正常启动，即部署成功。</p>

      <h3>🎉 最终部署成果</h3>
      <ul>
        <li>✔ 已成功创建 <code>/disk/haoyun</code> 工作目录</li>
        <li>✔ Miniconda 安装成功</li>
        <li>✔ Python 3.9 环境（pymarl2）配置完成</li>
        <li>✔ PyMARL2 克隆成功</li>
        <li>✔ 所有依赖已安装</li>
        <li>✔ PyTorch 2.5.1 + cu121 可用（支持 CUDA 12.2）</li>
        <li>✔ GPU（RTX 3090 × 7）可正常训练</li>
        <li>✔ SMAC 环境可用</li>
        <li>✔ 能够直接运行 QMIX、VDN、QPLEX 等 Q 系 MARL 算法</li>
      </ul>
    </section>

    <!-- Part 0: UAV-MARL Overview -->
    <section id="part0" class="chapter">
      <h2>Part 0：无人机多智能体任务简介（UAV-MARL Overview）</h2>
      <p>本页面聚焦多无人机（Multi-UAV）任务中的 MARL 方法、挑战与工程实践，保留 MARL 的通用背景但以无人机应用为主线。</p>

      <h3>多无人机系统（Multi-UAV Systems）简介</h3>
      <p>多无人机系统由若干自主或半自主 UAV 协同完成任务。常见任务包括围捕（encirclement）、追逃（pursuit–evasion）、对抗/空战、目标跟踪、搜救与编队控制。</p>

      <h3>典型任务：围捕 / 追逃（Pursuit–Evasion）</h3>
      <p>围捕任务通常要求多架友军 UAV 协同围堵并拦截目标（敌方 UAV），追逃任务则是高速动态对抗，强调连续动作控制与实时决策。</p>

      <h3>为什么 MARL 适合 UAV 任务</h3>
      <ul>
        <li><strong>通信受限：</strong>无线带宽和时延限制使得分散式方法更贴合实战。</li>
        <li><strong>局部观测：</strong>每架 UAV 只能看到局部传感器信息（雷达/相机），适合 CTDE（集中训练、分散执行）范式。</li>
        <li><strong>协作需求：</strong>多无人机之间需要协同分工、队形控制与协同拦截。</li>
      </ul>

      <h3>无人机任务中的核心难点</h3>
      <ul>
        <li><strong>非平稳性</strong>：多智能体同时学习导致环境对单个智能体呈非平稳。</li>
        <li><strong>可扩展性</strong>：随着 UAV 数量增加，策略与训练复杂度上升。</li>
        <li><strong>动态拓扑</strong>：邻居关系随位置变化，通信/观测图不断变化。</li>
        <li><strong>真实物理约束</strong>：动力学、速度/加速度限制、碰撞约束、传感器噪声。</li>
      </ul>
    </section>

    <!-- Part 1: 基本 MARL 方法 -->
    <section id="part1" class="chapter">
      <h2>Part 1：解决无人机协作/对抗需要的基本 MARL 方法</h2>
      <p>本部分介绍在无人机场景中最常用的基础算法，作为工程基线与进阶算法的对照组。</p>

      <section id="iql" class="chapter">
        <h3>第 1 章：IQL（Independent Learning）— 基线</h3>
        <p>独立学习（IQL）将每架 UAV 视为独立的 RL 智能体，各自学习私有策略。优点是实现简单、无显式通信；缺点是严重的非平稳性，但作为基线非常有用。</p>
        <p>适用场景：快速原型、线下单机测试、作为对照组评估复杂协作算法的收益。</p>
      </section>

      <section id="vdn_qmix" class="chapter">
        <h3>第 2 章：VDN / QMIX（价值分解）— 小规模围捕的强力方法</h3>
        <p>VDN 与 QMIX 通过将全局 reward 分解为个体价值项，从而在 CTDE 框架下实现协作学习。QMIX 引入单调性约束使得联合 Q 的表示能力更强，常在小规模围捕任务中产生 emergent 的队形控制与封锁行为。</p>
        <ul>
          <li>如何将全局奖励合理分配到个体。</li>
          <li>QMIX 的结构如何支持局部 greedy 策略与全局最优的近似。</li>
        </ul>
      </section>

      <section id="maddpg_matd3_masac" class="chapter">
        <h3>第 3 章：MADDPG / MATD3 / MASAC（连续动作 + 对抗）</h3>
        <p>无人机动作为连续空间（推力、偏航、俯仰等），因此基于连续动作策略的算法尤为重要。</p>
        <ul>
          <li><strong>MADDPG</strong>：经典的集中式 critic、分散式 actor 框架，易于入门。</li>
          <li><strong>MATD3</strong>：在连续动作上更稳定，适合需要稳定逼近动作策略的场景。</li>
          <li><strong>MASAC</strong>：引入熵正则，探索能力好，适合非平稳对抗与复杂策略搜索。</li>
        </ul>
        <p>额外说明：追逃/对抗问题常需要把问题建模为博弈（game），并在 critic 中考虑对手/队友的行为。</p>
      </section>
    </section>

    <!-- Part 2: 高级方法 -->
    <section id="part2" class="chapter">
      <h2>Part 2：无人机协作与围捕的高级 MARL 方法</h2>
      <p>针对围捕、包围、截断与角色分工等任务的高级方法。</p>

      <section id="coma" class="chapter">
        <h3>第 4 章：COMA（信用分配）</h3>
        <p>COMA 引入反事实基准（counterfactual baseline）来区分个体对全局奖励的真实贡献，适合分析围捕中“谁贡献最大”的场景。</p>
      </section>

      <section id="mappo" class="chapter">
        <h3>第 5 章：MAPPO（Multi-Agent PPO）</h3>
        <p>MAPPO 是目前最通用的策略梯度类方法之一，适合大规模编队控制、高维观测输入（图像、雷达）和复杂协作任务。</p>
      </section>

      <section id="comm" class="chapter">
        <h3>第 6 章：显式通信 MARL（CommNet / TarMAC / DIAL）</h3>
        <p>显式通信机制能显著提升协作效率：CommNet 的平均消息适合队形同步，TarMAC 的选择性通信适合围捕中的目标分派，DIAL 允许端到端学习通信协议。</p>
      </section>
    </section>

    <!-- Part 3: Graph-MARL -->
    <section id="part3" class="chapter">
      <h2>Part 3：图神经网络 + 多智能体（Graph-MARL）</h2>
      <p>在无人机群体中，通信与观测通常由邻居图决定，GNN/Graph-Attention 是当前研究热点。</p>

      <section id="graph_marl" class="chapter">
        <h3>第 7 章：Graph-MARL</h3>
        <h4>7.1 GAT / GNN 在无人机围捕中的作用</h4>
        <p>GNN 能动态编码邻居关系、学习注意力权重，帮助实现自适应队形与邻居选择。</p>
        <h4>7.2 DGN（Deep Graph Network for MARL）</h4>
        <p>DGN 处理动态拓扑，对编队与合围任务非常适合。</p>
        <h4>7.3 G2ANet（Graph Attention Actor-Critic）</h4>
        <p>以注意力机制强化“谁重要”的信息融合，增强局部通信的表达能力。</p>
        <h4>7.4 Graph-MAPPO / Graph-MADDPG</h4>
        <p>将 GNN 与集中式 critic 结合，可用于编码邻居信息并提高 critic 的评估能力。</p>
      </section>
    </section>

    <!-- Part 4: 对抗博弈 -->
    <section id="part4" class="chapter">
      <h2>Part 4：无人机对抗博弈 MARL 方法</h2>
      <h3>第 8 章：对抗 MARL（Mixed Games）</h3>
      <p>介绍常用的对抗算法与博弈论方法：Minimax、Nash Q、PSRO 等，以及其在无人机蓝红对抗中的应用。</p>
    </section>

    <!-- Part 5: 案例与工程 -->
    <section id="part5" class="chapter">
      <h2>Part 5：案例、工程实现与模拟器指南</h2>

      <section id="papers" class="chapter">
        <h3>第 9 章：经典无人机 MARL 论文总结</h3>
        <p>按领域汇总重要论文：追逃（Pursuit–Evasion）、协作围捕、空战、集群控制等。</p>
      </section>

      <section id="sims" class="chapter">
        <h3>第 10 章：模拟器与工程实现指南</h3>
        <ul>
          <li><strong>gym-pybullet-drones</strong>：常用 UAV RL 环境，适合快速原型与物理约束模拟。</li>
          <li><strong>AirSim</strong>：微软的高保真飞行仿真平台，适合视觉 / 传感器任务。</li>
          <li><strong>PettingZoo</strong>：多智能体环境集合，便于算法对比。</li>
          <li><strong>Isaac Gym</strong>：适合大规模并行训练与物理加速。</li>
          <li><strong>MARLlib</strong>：开箱即用的 MARL 基准库。</li>
        </ul>
      </section>
    </section>

    <!-- 总结与展望 -->
    <section id="summary" class="chapter">
      <h2>总结与展望</h2>
      <p>该文档将以无人机任务为主线，逐章展开算法原理、工程实现与案例，对研究与工程应用均有参考价值。</p>
    </section>
  </main>
</div>

<footer>
  <p>© 2025 <span>Haoyun Tang</span> | Multi-Agent Reinforcement Learning Notes</p>
</footer>

<script>
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('pre[class*="language-"]').forEach(pre => {
    if (!pre.classList.contains('line-numbers')) {
      pre.classList.add('line-numbers');
    }
  });
  if (window.Prism) {
    Prism.highlightAll();
  }
});

window.addEventListener('load', () => {
  if (window.Prism) {
    Prism.highlightAll();
  }
});

const navLinks = document.querySelectorAll('nav a');
const asideLinks = document.querySelectorAll('aside a');
const combined = [...navLinks, ...asideLinks];

window.addEventListener('scroll', () => {
  const offset = window.scrollY + 160;
  combined.forEach(link => {
    const section = document.querySelector(link.getAttribute('href'));
    if (!section) return;
    if (section.offsetTop <= offset && section.offsetTop + section.offsetHeight > offset) {
      link.classList.add('active');
    } else {
      link.classList.remove('active');
    }
  });
});
</script>
</body>
</html>
